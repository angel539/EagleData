/*
 * generated by Xtext 2.9.2
 */
package eagledata.core.dsl.rule.serializer;

import com.google.inject.Inject;
import eagledata.core.dsl.rule.ruleDsl.AddingSelect;
import eagledata.core.dsl.rule.ruleDsl.ComplexOperand;
import eagledata.core.dsl.rule.ruleDsl.Expression;
import eagledata.core.dsl.rule.ruleDsl.Numeral;
import eagledata.core.dsl.rule.ruleDsl.Query;
import eagledata.core.dsl.rule.ruleDsl.QueryOperand;
import eagledata.core.dsl.rule.ruleDsl.Rule;
import eagledata.core.dsl.rule.ruleDsl.RuleDslPackage;
import eagledata.core.dsl.rule.ruleDsl.RuleModel;
import eagledata.core.dsl.rule.ruleDsl.Selection;
import eagledata.core.dsl.rule.ruleDsl.SetSelect;
import eagledata.core.dsl.rule.ruleDsl.When;
import eagledata.core.dsl.rule.ruleDsl.Where;
import eagledata.core.dsl.rule.services.RuleDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RuleDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RuleDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RuleDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RuleDslPackage.ADDING_SELECT:
				sequence_AddingSelect(context, (AddingSelect) semanticObject); 
				return; 
			case RuleDslPackage.COMPLEX_OPERAND:
				sequence_ComplexOperand(context, (ComplexOperand) semanticObject); 
				return; 
			case RuleDslPackage.EXPRESSION:
				if (rule == grammarAccess.getComplexExpressionRule()) {
					sequence_ComplexExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_ComplexExpression_PlainExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPlainExpressionRule()) {
					sequence_PlainExpression(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case RuleDslPackage.NUMERAL:
				sequence_Numeral(context, (Numeral) semanticObject); 
				return; 
			case RuleDslPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case RuleDslPackage.QUERY_OPERAND:
				sequence_QueryOperand(context, (QueryOperand) semanticObject); 
				return; 
			case RuleDslPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case RuleDslPackage.RULE_MODEL:
				sequence_RuleModel(context, (RuleModel) semanticObject); 
				return; 
			case RuleDslPackage.SELECTION:
				sequence_Selection(context, (Selection) semanticObject); 
				return; 
			case RuleDslPackage.SET_SELECT:
				sequence_SetSelect(context, (SetSelect) semanticObject); 
				return; 
			case RuleDslPackage.WHEN:
				sequence_When(context, (When) semanticObject); 
				return; 
			case RuleDslPackage.WHERE:
				sequence_Where(context, (Where) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Select returns AddingSelect
	 *     AddingSelect returns AddingSelect
	 *
	 * Constraint:
	 *     (operation=SELECTOPERATOR (element=[Concept|ID] | all?='*')?)
	 */
	protected void sequence_AddingSelect(ISerializationContext context, AddingSelect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexExpression returns Expression
	 *
	 * Constraint:
	 *     (plainOperand=PlainOperand (complexOperands+=ComplexOperand complexOperands+=ComplexOperand*)?)
	 */
	protected void sequence_ComplexExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (plainOperand=PlainOperand | (plainOperand=PlainOperand (complexOperands+=ComplexOperand complexOperands+=ComplexOperand*)?))
	 */
	protected void sequence_ComplexExpression_PlainExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns ComplexOperand
	 *     ComplexOperand returns ComplexOperand
	 *
	 * Constraint:
	 *     (operator=OPERATOR expression=Expression)
	 */
	protected void sequence_ComplexOperand(ISerializationContext context, ComplexOperand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.COMPLEX_OPERAND__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.COMPLEX_OPERAND__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.COMPLEX_OPERAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.COMPLEX_OPERAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexOperandAccess().getOperatorOPERATORTerminalRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getComplexOperandAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Numeral
	 *     PlainOperand returns Numeral
	 *     Numeral returns Numeral
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_Numeral(ISerializationContext context, Numeral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.NUMERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.NUMERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumeralAccess().getValueDOUBLETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PlainExpression returns Expression
	 *
	 * Constraint:
	 *     plainOperand=PlainOperand
	 */
	protected void sequence_PlainExpression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.EXPRESSION__PLAIN_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.EXPRESSION__PLAIN_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlainExpressionAccess().getPlainOperandPlainOperandParserRuleCall_0(), semanticObject.getPlainOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns QueryOperand
	 *     PlainOperand returns QueryOperand
	 *     QueryOperand returns QueryOperand
	 *
	 * Constraint:
	 *     query=[Query|ID]
	 */
	protected void sequence_QueryOperand(ISerializationContext context, QueryOperand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.QUERY_OPERAND__QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.QUERY_OPERAND__QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQueryOperandAccess().getQueryQueryIDTerminalRuleCall_0_1(), semanticObject.getQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns Query
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (name=ID select=Select where=Where?)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleModel returns RuleModel
	 *
	 * Constraint:
	 *     (elements+=RuleElement elements+=RuleElement*)
	 */
	protected void sequence_RuleModel(ISerializationContext context, RuleModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns Rule
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=ID event=[Phrase|ID] condition=When? actions+=Query actions+=Query*)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Selection returns Selection
	 *
	 * Constraint:
	 *     (selector=[Concept|ID]? root+=[Concept|ID] root+=[Concept|ID]*)
	 */
	protected void sequence_Selection(ISerializationContext context, Selection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Select returns SetSelect
	 *     SetSelect returns SetSelect
	 *
	 * Constraint:
	 *     (((selection+=Selection selection+=Selection*) | all?='*')? (operator=SETOPERATOR select=SetSelect)?)
	 */
	protected void sequence_SetSelect(ISerializationContext context, SetSelect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     When returns When
	 *
	 * Constraint:
	 *     (left=Expression logicalOperator=LOGICALOPERATOR right=Expression)
	 */
	protected void sequence_When(ISerializationContext context, When semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.WHEN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.WHEN__LEFT));
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.WHEN__LOGICAL_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.WHEN__LOGICAL_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.WHEN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.WHEN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhenAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getWhenAccess().getLogicalOperatorLOGICALOPERATORTerminalRuleCall_2_0(), semanticObject.getLogicalOperator());
		feeder.accept(grammarAccess.getWhenAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Where returns Where
	 *
	 * Constraint:
	 *     (left=[Concept|ID] logicalOperator=LOGICALOPERATOR (rightVariable=[Concept|ID] | right=INT))
	 */
	protected void sequence_Where(ISerializationContext context, Where semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
