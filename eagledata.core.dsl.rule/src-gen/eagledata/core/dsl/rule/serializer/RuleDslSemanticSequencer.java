/*
 * generated by Xtext 2.9.2
 */
package eagledata.core.dsl.rule.serializer;

import com.google.inject.Inject;
import eagledata.core.dsl.pattern.streamingDsl.Import;
import eagledata.core.dsl.pattern.streamingDsl.StreamingDslPackage;
import eagledata.core.dsl.rule.ruleDsl.AddingSelect;
import eagledata.core.dsl.rule.ruleDsl.ComplexOperand;
import eagledata.core.dsl.rule.ruleDsl.DistributionList;
import eagledata.core.dsl.rule.ruleDsl.Expression;
import eagledata.core.dsl.rule.ruleDsl.Message;
import eagledata.core.dsl.rule.ruleDsl.Numeral;
import eagledata.core.dsl.rule.ruleDsl.Query;
import eagledata.core.dsl.rule.ruleDsl.QueryOperand;
import eagledata.core.dsl.rule.ruleDsl.ReceiverList;
import eagledata.core.dsl.rule.ruleDsl.Rule;
import eagledata.core.dsl.rule.ruleDsl.RuleDslPackage;
import eagledata.core.dsl.rule.ruleDsl.RuleModel;
import eagledata.core.dsl.rule.ruleDsl.SelectMessageString;
import eagledata.core.dsl.rule.ruleDsl.SetSelect;
import eagledata.core.dsl.rule.ruleDsl.TextMessageString;
import eagledata.core.dsl.rule.ruleDsl.When;
import eagledata.core.dsl.rule.ruleDsl.Where;
import eagledata.core.dsl.rule.services.RuleDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RuleDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RuleDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RuleDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RuleDslPackage.ADDING_SELECT:
				sequence_AddingSelect(context, (AddingSelect) semanticObject); 
				return; 
			case RuleDslPackage.COMPLEX_OPERAND:
				sequence_ComplexOperand(context, (ComplexOperand) semanticObject); 
				return; 
			case RuleDslPackage.DISTRIBUTION_LIST:
				sequence_DistributionList(context, (DistributionList) semanticObject); 
				return; 
			case RuleDslPackage.EXPRESSION:
				if (rule == grammarAccess.getComplexExpressionRule()) {
					sequence_ComplexExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_ComplexExpression_PlainExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPlainExpressionRule()) {
					sequence_PlainExpression(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case RuleDslPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case RuleDslPackage.NUMERAL:
				sequence_Numeral(context, (Numeral) semanticObject); 
				return; 
			case RuleDslPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case RuleDslPackage.QUERY_OPERAND:
				sequence_QueryOperand(context, (QueryOperand) semanticObject); 
				return; 
			case RuleDslPackage.RECEIVER_LIST:
				sequence_ReceiverList(context, (ReceiverList) semanticObject); 
				return; 
			case RuleDslPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case RuleDslPackage.RULE_MODEL:
				sequence_RuleModel(context, (RuleModel) semanticObject); 
				return; 
			case RuleDslPackage.SELECT_MESSAGE_STRING:
				sequence_SelectMessageString(context, (SelectMessageString) semanticObject); 
				return; 
			case RuleDslPackage.SET_SELECT:
				sequence_SetSelect(context, (SetSelect) semanticObject); 
				return; 
			case RuleDslPackage.TEXT_MESSAGE_STRING:
				sequence_TextMessageString(context, (TextMessageString) semanticObject); 
				return; 
			case RuleDslPackage.WHEN:
				sequence_When(context, (When) semanticObject); 
				return; 
			case RuleDslPackage.WHERE:
				sequence_Where(context, (Where) semanticObject); 
				return; 
			}
		else if (epackage == StreamingDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StreamingDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AddingSelect returns AddingSelect
	 *     Select returns AddingSelect
	 *
	 * Constraint:
	 *     (operation=SELECTOPERATOR (element=[Concept|ID] | all?='*')?)
	 */
	protected void sequence_AddingSelect(ISerializationContext context, AddingSelect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexExpression returns Expression
	 *
	 * Constraint:
	 *     (plainOperand=PlainOperand (complexOperands+=ComplexOperand complexOperands+=ComplexOperand*)?)
	 */
	protected void sequence_ComplexExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (plainOperand=PlainOperand | (plainOperand=PlainOperand (complexOperands+=ComplexOperand complexOperands+=ComplexOperand*)?))
	 */
	protected void sequence_ComplexExpression_PlainExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns ComplexOperand
	 *     ComplexOperand returns ComplexOperand
	 *
	 * Constraint:
	 *     (operator=OPERATOR expression=Expression)
	 */
	protected void sequence_ComplexOperand(ISerializationContext context, ComplexOperand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.COMPLEX_OPERAND__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.COMPLEX_OPERAND__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.COMPLEX_OPERAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.COMPLEX_OPERAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexOperandAccess().getOperatorOPERATORTerminalRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getComplexOperandAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Receiver returns DistributionList
	 *     DistributionList returns DistributionList
	 *
	 * Constraint:
	 *     file+=STRING
	 */
	protected void sequence_DistributionList(ISerializationContext context, DistributionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns Message
	 *     Action returns Message
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (name=ID message+=MessageString message+=MessageString* recipient=Receiver?)
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Numeral
	 *     PlainOperand returns Numeral
	 *     Numeral returns Numeral
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_Numeral(ISerializationContext context, Numeral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.NUMERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.NUMERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumeralAccess().getValueDOUBLETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PlainExpression returns Expression
	 *
	 * Constraint:
	 *     plainOperand=PlainOperand
	 */
	protected void sequence_PlainExpression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.EXPRESSION__PLAIN_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.EXPRESSION__PLAIN_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlainExpressionAccess().getPlainOperandPlainOperandParserRuleCall_0(), semanticObject.getPlainOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns QueryOperand
	 *     PlainOperand returns QueryOperand
	 *     QueryOperand returns QueryOperand
	 *
	 * Constraint:
	 *     query=[Query|ID]
	 */
	protected void sequence_QueryOperand(ISerializationContext context, QueryOperand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.QUERY_OPERAND__QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.QUERY_OPERAND__QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQueryOperandAccess().getQueryQueryIDTerminalRuleCall_0_1(), semanticObject.getQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns Query
	 *     Action returns Query
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (name=ID select=Select then+=Message then+=Message*)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Receiver returns ReceiverList
	 *     ReceiverList returns ReceiverList
	 *
	 * Constraint:
	 *     (receiver+=STRING receiver+=STRING*)
	 */
	protected void sequence_ReceiverList(ISerializationContext context, ReceiverList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleModel returns RuleModel
	 *
	 * Constraint:
	 *     ((imports+=Import imports+=Import* (elements+=Rule elements+=Rule*)) | (elements+=Rule elements+=Rule*))?
	 */
	protected void sequence_RuleModel(ISerializationContext context, RuleModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=ID event=[Phrase|ID] actions+=Action actions+=Action*)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageString returns SelectMessageString
	 *     SelectMessageString returns SelectMessageString
	 *
	 * Constraint:
	 *     (response+=[PrimitiveNode|QualifiedName] response+=[PrimitiveNode|QualifiedName]*)
	 */
	protected void sequence_SelectMessageString(ISerializationContext context, SelectMessageString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Select returns SetSelect
	 *     SetSelect returns SetSelect
	 *
	 * Constraint:
	 *     (
	 *         selector+=[PrimitiveNode|QualifiedName] 
	 *         selector+=[PrimitiveNode|QualifiedName]* 
	 *         from+=[DataDescription|QualifiedName] 
	 *         from+=[DataDescription|QualifiedName]* 
	 *         (where+=Where where+=Where*)?
	 *     )
	 */
	protected void sequence_SetSelect(ISerializationContext context, SetSelect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageString returns TextMessageString
	 *     TextMessageString returns TextMessageString
	 *
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_TextMessageString(ISerializationContext context, TextMessageString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.TEXT_MESSAGE_STRING__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.TEXT_MESSAGE_STRING__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTextMessageStringAccess().getTextSTRINGTerminalRuleCall_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     When returns When
	 *
	 * Constraint:
	 *     (left=Expression logicalOperator=LOGICALOPERATOR right=Expression)
	 */
	protected void sequence_When(ISerializationContext context, When semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.WHEN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.WHEN__LEFT));
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.WHEN__LOGICAL_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.WHEN__LOGICAL_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, RuleDslPackage.Literals.WHEN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RuleDslPackage.Literals.WHEN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhenAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getWhenAccess().getLogicalOperatorLOGICALOPERATORTerminalRuleCall_2_0(), semanticObject.getLogicalOperator());
		feeder.accept(grammarAccess.getWhenAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Where returns Where
	 *
	 * Constraint:
	 *     (
	 *         left=[PrimitiveNode|QualifiedName] 
	 *         logicalOperator=LOGICALOPERATOR 
	 *         (right=[PrimitiveNode|QualifiedName] | rightStreaming=[Concept|QualifiedName])
	 *     )
	 */
	protected void sequence_Where(ISerializationContext context, Where semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
