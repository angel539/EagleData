//grammar eagledata.core.dsl.rule.RuleDsl with org.eclipse.xtext.common.Terminals
grammar eagledata.core.dsl.rule.RuleDsl with org.eclipse.xtext.xbase.Xbase 

generate ruleDsl "http://www.core.eagledata/dsl/rule/RuleDsl" as rule
import "http://www.core.eagledata/dsl/streamingdata/StreamingDsl" as streaming
import "http://www.core.eagledata/dsl/datadesc/DataDsl" as data

RuleModel returns rule::RuleModel:
	importSection = XImportSection?
	//(imports += Import (imports += Import)*)?
	(elements+=Rule (elements+=Rule)*)? 
;

/*Import returns rule::Import:
    'import' importedNamespace = QualifiedNameWithWildcard;
    
QualifiedNameWithWildcard:
    QualifiedName '.*'?;
    
QualifiedName:
    ID ('.' ID)*;*/

/*RuleElement returns rule::RuleElement:
	Action
;*/

Rule returns rule::Rule:
	name=ID '{'
		'on' event = [streaming::Phrase | ValidID]
		'do' '{' (actions+=Action (actions+=Action)*)
		'}'
	'}'
;	

Action returns rule::Action:
	Query | Message
;

Query returns rule::Query:
	name=ID ':' select=Select 'then' '{'(then += Message (then += Message)*)'}'
;
	
AddingSelect returns rule::AddingSelect:
	operation=SELECTOPERATOR ((element=[streaming::Feature | ValidID])? | (all?='*'))
;	
	
Select returns rule::Select:
	AddingSelect | SetSelect
;

SetSelect returns rule::SetSelect:
	'select' 
	/*validid antes era QualifiedName*/
		(selector += [data::PrimitiveNode | ValidID] (',' selector += [data::PrimitiveNode | ValidID])*) 
		'from' (from += [data::DataDescription | ValidID] (',' from += [data::DataDescription | ValidID])*)
		('where' (where += Where ('and' where += Where)*))?
	//'select' (selection+=Selection ( "," selection+=Selection)*)?
	//'select' (selection += [data::PrimitiveNode | ID] (',' selection += [data::PrimitiveNode | ID])*)
	//(operator=SETOPERATOR select=SetSelect)?
;

/*SetOperatorPatternSelect returns rule::SetOperator:
	UnionPatternSelect | IntersectPatternSelect | ExceptPatternSelect;

UnionPatternSelect returns rule::Union:
	'union' select=SetSelect;

IntersectPatternSelect returns rule::Intersect:
	'intersect' select=SetSelect;

ExceptPatternSelect returns rule::Except:
	'except' select=SetSelect;*/

//Selection returns rule::Selection:
	//(selector=[streaming::Concept | ID] '.')? (root+=[streaming::Concept | ID] ('.'root+=[streaming::Concept | ID])*)
	//(selector=[streaming::Concept | ID] '.')? (root+=[streaming::Concept | ID] ('.'root+=[streaming::Concept | ID])*)
//;



/*enum OperationAddingSelect returns rule::OperationAddingSelect:
	count = 'count' //| min = 'min' | max = 'max' | add = 'add' | avg = 'avg'
;*/
		
Where returns rule::Where:
	left=[data::PrimitiveNode|ValidID] logicalOperator=LOGICALOPERATOR (right=[data::PrimitiveNode|ValidID] | '{'rightStreaming=[streaming::Feature|ValidID]'}');

//===========================================================================================
//When --> Expressions

When returns rule::When:
	'when' left=Expression logicalOperator=LOGICALOPERATOR right=Expression;

Expression returns rule::Expression:
	PlainExpression | ComplexExpression;

PlainExpression returns rule::Expression:
	plainOperand=PlainOperand
;

ComplexExpression returns rule::Expression:
	'(' plainOperand=PlainOperand (complexOperands+=ComplexOperand (complexOperands+=ComplexOperand)*)? ')'
;

Operand returns rule::Operand:
PlainOperand | ComplexOperand;

PlainOperand returns rule::PlainOperand:
	Numeral | QueryOperand;

Numeral returns rule::Numeral:
	value = DOUBLE;

QueryOperand returns rule::QueryOperand:
	query=[rule::Query|ID];

ComplexOperand returns rule::ComplexOperand:
	operator=OPERATOR expression=Expression;

/*ArithmeticalOperator returns rule::ArithmeticalOperator:
	Addition | Subtraction | Multiplication | Division;


Addition returns rule::Addition: '+';

Subtraction returns rule::Subtraction: '-';

Multiplication returns rule::Multiplication: '*';

Division returns rule::Division: '/';*/

/*LogicalOperator returns rule::LogicalOperator:
	MoreThan | LessThan | MoreEqual | LessEqual | Equal;

MoreThan returns expression::MoreThan:
	{expression::MoreThan} '>' ;
	
LessThan returns expression::LessThan:
	{expression::LessThan} '<' ;

MoreEqual returns expression::MoreEqual:
	{expression::MoreEqual} '>=' ;
	
LessEqual returns expression::LessEqual:
	{expression::LessEqual} '<=' ;
	
Equal returns expression::Equal:
	{expression::Equal} '=' ;*/

/*EString returns ecore::EString:
	STRING | ID;

EBoolean returns ecore::EBoolean:
	'true' | 'false';
	
EInt returns ecore::EInt:
	'-'? INT;
	
EFloat returns ecore::EFloat:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;*/

Message returns rule::Message:
	name=ID ':' 'compose' (message += MessageString ('+' message += MessageString)*) ('to' recipient = Receiver)?
;

MessageString returns rule::MessageString:
	TextMessageString | SelectMessageString// | OperationMessageString
;	

SelectMessageString returns rule::SelectMessageString:
	'{'(response += [data::PrimitiveNode | QualifiedName] (',' response += [data::PrimitiveNode | QualifiedName])*)'}'
;

//OperationMessageString returns rule::OperationMessageString:
//    '['body=XBlockExpression']'
//;

TextMessageString returns rule::TextMessageString:
	text=STRING
;

Receiver returns rule::Receiver:
	ReceiverList | DistributionList
;

ReceiverList returns rule::ReceiverList:
	'{'(receiver += STRING (',' receiver += STRING)*)'}'
;

DistributionList returns rule::DistributionList:
	'@'(file += STRING)
;

terminal OPERATOR : '+' | '-' | '*' | 'DIV';
terminal LOGICALOPERATOR : '>' | '<' | '>=' | '<=' | '=';
terminal CONDITIONALOPERATOR : 'AND' | 'OR';

/*enum OperationAddingSelect returns rule::OperationAddingSelect:
	count = 'count' //| min = 'min' | max = 'max' | add = 'add' | avg = 'avg'
;*/
terminal SELECTOPERATOR : 'COUNT' | 'MIN' | 'MAX';
terminal DOUBLE : INT '.' INT;
terminal SETOPERATOR : 'UNION' | 'EXCEPT' | 'INTERSECT';
