/*
 * generated by Xtext 2.9.2
 */
package eagledata.core.dsl.datadesc.serializer;

import com.google.inject.Inject;
import eagledata.core.dsl.datadesc.dataDsl.BooleanOption;
import eagledata.core.dsl.datadesc.dataDsl.Cardinality;
import eagledata.core.dsl.datadesc.dataDsl.CompositeNode;
import eagledata.core.dsl.datadesc.dataDsl.DataDescription;
import eagledata.core.dsl.datadesc.dataDsl.DataDslPackage;
import eagledata.core.dsl.datadesc.dataDsl.DataModel;
import eagledata.core.dsl.datadesc.dataDsl.DataOption;
import eagledata.core.dsl.datadesc.dataDsl.DataTypeRefinement;
import eagledata.core.dsl.datadesc.dataDsl.DoubleOption;
import eagledata.core.dsl.datadesc.dataDsl.Enumeration;
import eagledata.core.dsl.datadesc.dataDsl.Fragment;
import eagledata.core.dsl.datadesc.dataDsl.FragmentNode;
import eagledata.core.dsl.datadesc.dataDsl.Import;
import eagledata.core.dsl.datadesc.dataDsl.IntOption;
import eagledata.core.dsl.datadesc.dataDsl.ListQualifiedNameOption;
import eagledata.core.dsl.datadesc.dataDsl.PrimitiveNode;
import eagledata.core.dsl.datadesc.dataDsl.StringOption;
import eagledata.core.dsl.datadesc.dataDsl.Substring;
import eagledata.core.dsl.datadesc.dataDsl.Tag;
import eagledata.core.dsl.datadesc.services.DataDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DataDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DataDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DataDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DataDslPackage.BOOLEAN_OPTION:
				sequence_BooleanOption(context, (BooleanOption) semanticObject); 
				return; 
			case DataDslPackage.CARDINALITY:
				sequence_Cardinality(context, (Cardinality) semanticObject); 
				return; 
			case DataDslPackage.CHARACTER:
				sequence_Character(context, (eagledata.core.dsl.datadesc.dataDsl.Character) semanticObject); 
				return; 
			case DataDslPackage.COMPOSITE_NODE:
				sequence_CompositeNode(context, (CompositeNode) semanticObject); 
				return; 
			case DataDslPackage.DATA_DESCRIPTION:
				sequence_DataDescription(context, (DataDescription) semanticObject); 
				return; 
			case DataDslPackage.DATA_MODEL:
				sequence_DataModel(context, (DataModel) semanticObject); 
				return; 
			case DataDslPackage.DATA_OPTION:
				sequence_DataOption(context, (DataOption) semanticObject); 
				return; 
			case DataDslPackage.DATA_TYPE_REFINEMENT:
				sequence_DataTypeRefinement(context, (DataTypeRefinement) semanticObject); 
				return; 
			case DataDslPackage.DOUBLE_OPTION:
				sequence_DoubleOption(context, (DoubleOption) semanticObject); 
				return; 
			case DataDslPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case DataDslPackage.FRAGMENT:
				sequence_Fragment(context, (Fragment) semanticObject); 
				return; 
			case DataDslPackage.FRAGMENT_NODE:
				sequence_FragmentNode(context, (FragmentNode) semanticObject); 
				return; 
			case DataDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case DataDslPackage.INT_OPTION:
				sequence_IntOption(context, (IntOption) semanticObject); 
				return; 
			case DataDslPackage.LIST_QUALIFIED_NAME_OPTION:
				sequence_ListQualifiedNameOption(context, (ListQualifiedNameOption) semanticObject); 
				return; 
			case DataDslPackage.PACKAGE:
				sequence_Package(context, (eagledata.core.dsl.datadesc.dataDsl.Package) semanticObject); 
				return; 
			case DataDslPackage.PRIMITIVE_NODE:
				sequence_PrimitiveNode(context, (PrimitiveNode) semanticObject); 
				return; 
			case DataDslPackage.STRING_OPTION:
				sequence_StringOption(context, (StringOption) semanticObject); 
				return; 
			case DataDslPackage.SUBSTRING:
				sequence_Substring(context, (Substring) semanticObject); 
				return; 
			case DataDslPackage.TAG:
				sequence_Tag(context, (Tag) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Option returns BooleanOption
	 *     BooleanOption returns BooleanOption
	 *
	 * Constraint:
	 *     (key=BooleanOptionKey value=BOOLEAN)
	 */
	protected void sequence_BooleanOption(ISerializationContext context, BooleanOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.BOOLEAN_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.BOOLEAN_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.BOOLEAN_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.BOOLEAN_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanOptionAccess().getKeyBooleanOptionKeyEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getBooleanOptionAccess().getValueBOOLEANTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Cardinality returns Cardinality
	 *
	 * Constraint:
	 *     (min=CARDINALITY_SYMBOLS max=CARDINALITY_SYMBOLS?)
	 */
	protected void sequence_Cardinality(ISerializationContext context, Cardinality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubstringConcept returns Character
	 *     Character returns Character
	 *
	 * Constraint:
	 *     (typeCharacter=TypeCharacter name=ID value=STRING?)
	 */
	protected void sequence_Character(ISerializationContext context, eagledata.core.dsl.datadesc.dataDsl.Character semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns CompositeNode
	 *     CompositeNode returns CompositeNode
	 *
	 * Constraint:
	 *     ((key?='key' | unique?='unique')? type=[TypeSpecification|QualifiedName] name=ID cardinality=Cardinality? (options+=Option options+=Option*)?)
	 */
	protected void sequence_CompositeNode(ISerializationContext context, CompositeNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataModelElement returns DataDescription
	 *     SpecificationElement returns DataDescription
	 *     AbstractDescription returns DataDescription
	 *     DataDescription returns DataDescription
	 *
	 * Constraint:
	 *     (
	 *         format=STRING 
	 *         name=ID 
	 *         (fragments+=[Fragment|QualifiedName] fragments+=[Fragment|QualifiedName]*)? 
	 *         (nodes+=Node nodes+=Node*)? 
	 *         (options+=DataOption options+=DataOption*)?
	 *     )
	 */
	protected void sequence_DataDescription(ISerializationContext context, DataDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataModel returns DataModel
	 *
	 * Constraint:
	 *     (elements+=DataModelElement elements+=DataModelElement*)
	 */
	protected void sequence_DataModel(ISerializationContext context, DataModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataOption returns DataOption
	 *
	 * Constraint:
	 *     (key=STRING value=STRING)
	 */
	protected void sequence_DataOption(ISerializationContext context, DataOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.DATA_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.DATA_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.DATA_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.DATA_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataOptionAccess().getKeySTRINGTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getDataOptionAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataModelElement returns DataTypeRefinement
	 *     SpecificationElement returns DataTypeRefinement
	 *     TypeSpecification returns DataTypeRefinement
	 *     DataTypeRefinement returns DataTypeRefinement
	 *
	 * Constraint:
	 *     (name=ID refine=BasicType (subsequences+=SubstringConcept subsequences+=SubstringConcept*)? (options+=Option options+=Option*)?)
	 */
	protected void sequence_DataTypeRefinement(ISerializationContext context, DataTypeRefinement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns DoubleOption
	 *     DoubleOption returns DoubleOption
	 *
	 * Constraint:
	 *     (key=DoubleOptionKey value=DOUBLE)
	 */
	protected void sequence_DoubleOption(ISerializationContext context, DoubleOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.DOUBLE_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.DOUBLE_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.DOUBLE_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.DOUBLE_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoubleOptionAccess().getKeyDoubleOptionKeyEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getDoubleOptionAccess().getValueDOUBLETerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataModelElement returns Enumeration
	 *     SpecificationElement returns Enumeration
	 *     TypeSpecification returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (name=ID values+=STRING values+=STRING*)
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns FragmentNode
	 *     FragmentNode returns FragmentNode
	 *
	 * Constraint:
	 *     (type=[Fragment|QualifiedName] name=ID cardinality=Cardinality? (options+=Option options+=Option*)?)
	 */
	protected void sequence_FragmentNode(ISerializationContext context, FragmentNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataModelElement returns Fragment
	 *     SpecificationElement returns Fragment
	 *     AbstractDescription returns Fragment
	 *     Fragment returns Fragment
	 *
	 * Constraint:
	 *     (name=ID (fragments+=[Fragment|QualifiedName] fragments+=[Fragment|QualifiedName]*)? nodes+=Node nodes+=Node*)
	 */
	protected void sequence_Fragment(ISerializationContext context, Fragment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *     DataModelElement returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns IntOption
	 *     IntOption returns IntOption
	 *
	 * Constraint:
	 *     (key=IntOptionKey value=INT)
	 */
	protected void sequence_IntOption(ISerializationContext context, IntOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.INT_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.INT_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.INT_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.INT_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntOptionAccess().getKeyIntOptionKeyEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getIntOptionAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns ListQualifiedNameOption
	 *     ListQualifiedNameOption returns ListQualifiedNameOption
	 *
	 * Constraint:
	 *     (key=ListQualifiedNameOptionKey fragments+=[Node|QualifiedName])
	 */
	protected void sequence_ListQualifiedNameOption(ISerializationContext context, ListQualifiedNameOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataModelElement returns Package
	 *     Package returns Package
	 *
	 * Constraint:
	 *     ((tags+=Tag tags+=Tag*)? name=QualifiedName elements+=SpecificationElement elements+=SpecificationElement*)
	 */
	protected void sequence_Package(ISerializationContext context, eagledata.core.dsl.datadesc.dataDsl.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns PrimitiveNode
	 *     PrimitiveNode returns PrimitiveNode
	 *
	 * Constraint:
	 *     ((key?='key' | unique?='unique')? type=BasicType name=ID cardinality=Cardinality? (options+=Option options+=Option*)?)
	 */
	protected void sequence_PrimitiveNode(ISerializationContext context, PrimitiveNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns StringOption
	 *     StringOption returns StringOption
	 *
	 * Constraint:
	 *     (key=StringOptionKey value=STRING)
	 */
	protected void sequence_StringOption(ISerializationContext context, StringOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.STRING_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.STRING_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.STRING_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.STRING_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringOptionAccess().getKeyStringOptionKeyEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getStringOptionAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubstringConcept returns Substring
	 *     Substring returns Substring
	 *
	 * Constraint:
	 *     (typeString=TypeString name=ID minlength=INT maxlength=INT)
	 */
	protected void sequence_Substring(ISerializationContext context, Substring semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.SUBSTRING__TYPE_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.SUBSTRING__TYPE_STRING));
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.SUBSTRING_CONCEPT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.SUBSTRING_CONCEPT__NAME));
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.SUBSTRING__MINLENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.SUBSTRING__MINLENGTH));
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.SUBSTRING__MAXLENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.SUBSTRING__MAXLENGTH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubstringAccess().getTypeStringTypeStringEnumRuleCall_0_0(), semanticObject.getTypeString());
		feeder.accept(grammarAccess.getSubstringAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSubstringAccess().getMinlengthINTTerminalRuleCall_3_0(), semanticObject.getMinlength());
		feeder.accept(grammarAccess.getSubstringAccess().getMaxlengthINTTerminalRuleCall_5_0(), semanticObject.getMaxlength());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Tag returns Tag
	 *
	 * Constraint:
	 *     tag=STRING
	 */
	protected void sequence_Tag(ISerializationContext context, Tag semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DataDslPackage.Literals.TAG__TAG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataDslPackage.Literals.TAG__TAG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTagAccess().getTagSTRINGTerminalRuleCall_1_0(), semanticObject.getTag());
		feeder.finish();
	}
	
	
}
