grammar eagledata.core.dsl.datadesc.DataDsl with org.eclipse.xtext.common.Terminals

generate dataDsl "http://www.core.eagledata/dsl/datadesc/DataDsl" as data
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DataModel returns data::DataModel:
	descriptions+=DataModelElement (descriptions+=DataModelElement)*
;

/******************** */
Import returns data::Import:
    'import' importedNamespace=QualifiedNameWithWildcard;
    
QualifiedNameWithWildcard:
    QualifiedName '.*'?;
    
QualifiedName:
    ID ('.' ID)*;
/******************** */

DataModelElement returns data::DataModelElement:
    Import | PackageDeclaration | DataPackableDescription | DataSourceDescription;

PackageDeclaration returns data::Package:
    'package' name=QualifiedName '{'
    			elements+=DataPackableDescription (elements+=DataPackableDescription)*
    '}'
;

DataPackableDescription returns data::DataPackableDescription:
	StringConcept | TypeSpecification | DataFragment
;

StringConcept returns data::StringConcept:
	'string' name=ID '=' '(' (subsequence+=SubstringConcept ( "," subsequence+=SubstringConcept)*)? ')';

SubstringConcept returns data::SubstringConcept:
	Character | Substring
;

Substring returns data::Substring:
	typeString=TypeString name=ID '['minlength=INT "," maxlength=INT']'//('{'properties+= ( "," properties+=Property)* '}')?
;

Character returns data::Character:
	typeCharacter=TypeCharacter name=ID (value=STRING)?
;

enum TypeCharacter returns data::TypeCharacter:
	char = 'char' | digit = 'digit'
;

enum TypeString returns data::TypeString:
	//ignoreaccents = 'ignore_accents' | ignorecase = 'ignore_case' | iglowercase = 'lower_case' | uppercase = 'upper_case' | numbers = 'numbers'
	anycase = 'anycase_string' | lowercase = 'lowercase_string' | uppercase = 'uppercase_string' | numbers = 'digits'
;

DataSourceDescription returns data::DataSourceDescription:
	'description' format=Format name=ID (':' fragments+=[data::DataFragment | QualifiedName] (',' fragments+=[data::DataFragment | QualifiedName])*)? '{'
		(nodes+=LeafNode ("," nodes+=LeafNode)*)?
	'}' ('{' options+=DataOption ("," options+=DataOption)* '}')?
;

DataFragment returns data::DataFragment:
	'fragment' name=ID (':' fragments+=[data::DataFragment | QualifiedName] (',' fragments+=[data::DataFragment | QualifiedName])*)? '{'
		(nodes += LeafNode ( "," nodes += LeafNode)*)?
	'}'
;

TypeSpecification returns data::TypeSpecification:
	DataType | Enumeration | StructDataType
;

DataType returns data::DataType:
	'datatype' name=ID ':' refine=BasicType ('{'options+=Option ( "," options+=Option)* '}')?
;

Enumeration returns data::Enumeration:
	'enumeration' name=ID "{"values+=STRING (','values += STRING)*"}"
;

/*Node returns data::Node:
	LeafNode
;*/

StructDataType returns data::StructDataType:
	/*(environment?=">")?*/
	'struct' name=ID /*(':' extends+=[data::CompositeNode | ID] (',' extends+=[data::CompositeNode | ID])*)?*/ '{'
		(subnodes+=LeafNode ( "," subnodes+=LeafNode)*)
	'}'
	('{' options += Option ( "," options+=Option)* '}')?
;

LeafNode returns data::LeafNode:
	/*(uniqueness=UNIQUENESS)?*/
	(key?="key" | unique?="unique" | list?="list")?
	(type=BasicType | typeCall=[data::TypeSpecification | ID]) name=ID ('{' options += Option ( "," options+=Option)* '}')?
;

enum Multiplicity returns data::Multiplicity:
	casesensitive = 'casesensitive' | null = 'null' |  separator = 'separator' | default = 'default' | regex = 'regex' | flags = 'flags' | decimalchar = 'decimalchar' | pattern = 'pattern' | format = 'format'
;

Option returns data::Option:
	StringOption | IntOption | BooleanOption | SequenceOption | DoubleOption
;

StringOption returns data::StringOption:
	key=StringOptionKey '=' value = STRING
;

IntOption returns data::IntOption:
	key=IntOptionKey '=' value = INT
;

DoubleOption returns data::DoubleOption:
	key=DoubleOptionKey '=' value = DOUBLE
;

BooleanOption returns data::BooleanOption:
	key=BooleanOptionKey '=' value = BOOLEAN
;

SequenceOption returns data::SequenceOption:
	key=SequenceOptionKey '=' value = [data::StringConcept|QualifiedName]
;

enum SequenceOptionKey returns data::SequenceOptionKey:
	regex_form = 'regex_form'
;

enum BasicType returns data::BasicType:
	string = 'string' | url = 'url' | int = 'int' | real = 'real' | date = 'date' | time = 'time' | year = 'year' | month = 'month' | day = 'day' | boolean = 'boolean' | lat = 'lat' | long = 'long'
;

enum StringOptionKey returns data::StringOptionKey:
	casesensitive = 'casesensitive' | null = 'null' |  separator = 'separator' | default = 'default' | regex = 'regex' | flags = 'flags' | decimalchar = 'decimalchar' | pattern = 'pattern' | format = 'format'
;

enum IntOptionKey returns data::IntOptionKey:
	minLength = 'minLength' | maxLength = 'maxLength' | min = 'min' | max = 'max' | default = 'defaultvalue'
;

enum DoubleOptionKey returns data::DoubleOptionKey:
	min = 'minDouble' | max = 'maxDouble' | default = 'defaultvalueDouble'
;

enum BooleanOptionKey returns data::BooleanOptionKey:
	nullable = "nullable"
;

DataOption returns data::DataOption:
	key=DataOptionKey '=' value = STRING
;

enum DataOptionKey returns data::DataOptionKey:
	format = 'format' | separator = 'separator' | header = 'header' | squema = 'squema'
;

enum Format returns data::Format:
	CSV = 'CSV' | JSON = 'JSON' | XML = 'XML'
;

terminal DELETATION_MARK : 'REMOVE';
terminal MODIFICATION_MARK : 'RENAME' | 'RETYPE';
//terminal UNIQUENESS : 'key' | 'unique';
terminal BOOLEAN : "true" | "false";

terminal DOUBLE returns ecore::EDouble: "-"?INT'.'INT;