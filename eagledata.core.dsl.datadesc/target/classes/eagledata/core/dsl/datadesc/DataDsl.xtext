grammar eagledata.core.dsl.datadesc.DataDsl with org.eclipse.xtext.common.Terminals

generate dataDsl "http://www.core.eagledata/dsl/datadesc/DataDsl" as data
//import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DataModel returns data::DataModel:
	{data::DataModel}
	elements+=DataModelElement (elements+=DataModelElement)*
;

/******************** */
Import returns data::Import:
    'import' importedNamespace=QualifiedNameWithWildcard;
    
QualifiedNameWithWildcard:
    QualifiedName '.*'?;
    
QualifiedName:
    ID ('.' ID)*;
/******************** */

DataModelElement returns data::DataModelElement:
    Import | Package | SpecificationElement;

Package returns data::Package:
	(tags+=Tag (tags+=Tag)*)?
    'package' name=QualifiedName '{'
    			elements+=SpecificationElement (elements+=SpecificationElement)*
    '}'
;

Tag returns data::Tag:
	'@'tag=STRING
;

SpecificationElement returns data::SpecificationElement:
	TypeSpecification | AbstractDescription
;

TypeSpecification returns data::TypeSpecification:
	DataTypeRefinement | Enumeration
;

AbstractDescription returns data::AbstractDescription:
	DataDescription | Fragment
;

SubstringConcept returns data::SubstringConcept:
	Character | Substring
;

Substring returns data::Substring:
	typeString=TypeString name=ID '['minlength=INT "," maxlength=INT']'
;

Character returns data::Character:
	typeCharacter=TypeCharacter name=ID (value=STRING)?
;

enum TypeCharacter returns data::TypeCharacter:
	char = 'char' | digit = 'digit'
;

enum TypeString returns data::TypeString:
	anycase = 'anycase_string' | lowercase = 'lowercase_string' | uppercase = 'uppercase_string' | numbers = 'digits'
;

Node returns data::Node:
	PrimitiveNode | CompositeNode | FragmentNode
;

CompositeNode returns data::CompositeNode:
	(key?="key" | unique?="unique")?
	type=[data::TypeSpecification | QualifiedName] name=ID ('['cardinality=Cardinality']')?	('(' options += Option ( "," options+=Option)* ')')?
;

FragmentNode returns data::FragmentNode:
	'.'type=[data::Fragment | QualifiedName] name=ID ('['cardinality=Cardinality']')?	('(' options += Option ( "," options+=Option)* ')')?
;

PrimitiveNode returns data::PrimitiveNode:
	(key?="key" | unique?="unique")?
	type=BasicType name=ID ('['cardinality=Cardinality']')?	('(' options += Option ( "," options+=Option)* ')')?
;

Cardinality returns data::Cardinality:
	min=CARDINALITY_SYMBOLS (',' max=CARDINALITY_SYMBOLS)?
;

DataDescription returns data::DataDescription:
	'description' format=STRING name=ID (':' fragments+=[data::Fragment | QualifiedName] (',' fragments+=[data::Fragment | QualifiedName])*)? '{'
		(nodes += Node (nodes += Node)*)?
	'}' ('(' options+=DataOption ("," options+=DataOption)* ')')?
;

Fragment returns data::Fragment:
	'fragment' name=ID (':' fragments+=[data::Fragment | QualifiedName] (',' fragments+=[data::Fragment | QualifiedName])*)? '{'
		nodes += Node (nodes += Node)*
	'}'
;


DataTypeRefinement returns data::DataTypeRefinement:
	'datatype' name=ID ':' refine=BasicType ('{'(subsequences+=SubstringConcept (subsequences+=SubstringConcept)*)? '}')? ('('options+=Option ( "," options+=Option)* ')')?
;

Enumeration returns data::Enumeration:
	'enumeration' name=ID "{"values+=STRING (','values += STRING)*"}"
;

Option returns data::Option:
	StringOption | IntOption | BooleanOption | DoubleOption | ListQualifiedNameOption
;

StringOption returns data::StringOption:
	key=StringOptionKey '=' value = STRING
;

IntOption returns data::IntOption:
	key=IntOptionKey '=' value = INT
;

DoubleOption returns data::DoubleOption:
	key=DoubleOptionKey '=' value = DOUBLE
;

BooleanOption returns data::BooleanOption:
	key=BooleanOptionKey '=' value = BOOLEAN
;

ListQualifiedNameOption returns data::ListQualifiedNameOption:
	key=ListQualifiedNameOptionKey '=' fragments+=[data::Node | QualifiedName] 
;

enum BasicType returns data::BasicType:
	string = 'String' | url = 'Url' | int = 'Int' | longInt = 'LongInt' | real = 'Real' | date = 'Date' | time = 'Time' | year = 'Year' | month = 'Month' | day = 'Day' | boolean = 'Boolean' | lat = 'Lat' | long = 'Long' | percent = 'Percent' | email = 'Email' | currency = 'Currency' | creditcard = 'CreditCard' | IBAN = 'IBAN' | ISBN = 'ISBN' | ISSN = 'ISSN' | inet = 'Inet'
;

enum StringOptionKey returns data::StringOptionKey:
	null = 'null' |  separator = 'separator' | default = 'default' | regex = 'regex' | flags = 'flags' | decimalchar = 'decimalchar' | pattern = 'pattern' | format = 'format'
;

enum IntOptionKey returns data::IntOptionKey:
	minLength = 'minLength' | maxLength = 'maxLength' | min = 'min' | max = 'max' | default = 'defaultvalue'
;

enum DoubleOptionKey returns data::DoubleOptionKey:
	min = 'minDouble' | max = 'maxDouble' | default = 'defaultvalueDouble'
;

enum BooleanOptionKey returns data::BooleanOptionKey:
	nullable = "nullable" | casesensitive = 'casesensitive'
;

enum ListQualifiedNameOptionKey returns data::ListQualifiedNameOptionKey:
	order = "order"
;

DataOption returns data::DataOption:
	key=STRING '=' value = STRING
;

/*DataOption returns data::DataOption:
	key=DataOptionKey '=' value = STRING
;*/

/*enum DataOptionKey returns data::DataOptionKey:
	format = 'format' | separator = 'separator' | header = 'header' | squema = 'squema'
;*/

/*enum Format returns data::Format:
	CSV = 'CSV' | JSON = 'JSON' | XML = 'XML'
;*/

//terminal DELETATION_MARK : 'REMOVE';
//terminal MODIFICATION_MARK : 'RENAME' | 'RETYPE';
//terminal UNIQUENESS : 'key' | 'unique';
terminal BOOLEAN : "true" | "false";
terminal CARDINALITY_SYMBOLS : "0" | "1" | "2" | "-1";
terminal NEGINT : "-"INT;
terminal DOUBLE returns ecore::EDouble: "-"?INT'.'INT;