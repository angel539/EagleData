/*
 * generated by Xtext 2.9.2
 */
package uam.eagledata.dsl.semanticnodes.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import semanticmanager.Annotation;
import semanticmanager.EnumDataProperty;
import semanticmanager.Enumeration;
import semanticmanager.EnumerationLiteral;
import semanticmanager.MetaData;
import semanticmanager.ObjectProperty;
import semanticmanager.PrimitiveTypeDataProperty;
import semanticmanager.Repository;
import semanticmanager.RepositoryManager;
import semanticmanager.Resource;
import semanticmanager.SemanticNode;
import semanticmanager.SemanticmanagerPackage;
import uam.eagledata.dsl.semanticnodes.services.SemanticNodesDslGrammarAccess;

@SuppressWarnings("all")
public class SemanticNodesDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SemanticNodesDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SemanticmanagerPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SemanticmanagerPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case SemanticmanagerPackage.ENUM_DATA_PROPERTY:
				sequence_EnumerationDataProperty(context, (EnumDataProperty) semanticObject); 
				return; 
			case SemanticmanagerPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case SemanticmanagerPackage.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case SemanticmanagerPackage.META_DATA:
				sequence_MetaData(context, (MetaData) semanticObject); 
				return; 
			case SemanticmanagerPackage.OBJECT_PROPERTY:
				sequence_ObjectProperty(context, (ObjectProperty) semanticObject); 
				return; 
			case SemanticmanagerPackage.PRIMITIVE_TYPE_DATA_PROPERTY:
				sequence_PrimitiveTypeDataProperty(context, (PrimitiveTypeDataProperty) semanticObject); 
				return; 
			case SemanticmanagerPackage.REPOSITORY:
				sequence_Repository(context, (Repository) semanticObject); 
				return; 
			case SemanticmanagerPackage.REPOSITORY_MANAGER:
				sequence_RepositoryManager(context, (RepositoryManager) semanticObject); 
				return; 
			case SemanticmanagerPackage.RESOURCE:
				sequence_Resource(context, (Resource) semanticObject); 
				return; 
			case SemanticmanagerPackage.SEMANTIC_NODE:
				sequence_SemanticNode(context, (SemanticNode) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     annotation=EString
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, SemanticmanagerPackage.Literals.ANNOTATION__ANNOTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, SemanticmanagerPackage.Literals.ANNOTATION__ANNOTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getAnnotationAccess().getAnnotationEStringParserRuleCall_2_0(), semanticObject.getAnnotation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns EnumDataProperty
	 *     EnumerationDataProperty returns EnumDataProperty
	 *
	 * Constraint:
	 *     (name=EString type=[Enumeration|EString] (lowerBound=EInt upperBound=EInt)? (metadata+=MetaData metadata+=MetaData*)?)
	 */
	protected void sequence_EnumerationDataProperty(ISerializationContext context, EnumDataProperty semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumerationLiteral returns EnumerationLiteral
	 *
	 * Constraint:
	 *     (value=EInt literal=EString)
	 */
	protected void sequence_EnumerationLiteral(ISerializationContext context, EnumerationLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, SemanticmanagerPackage.Literals.ENUMERATION_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, SemanticmanagerPackage.Literals.ENUMERATION_LITERAL__VALUE));
			if (transientValues.isValueTransient((EObject) semanticObject, SemanticmanagerPackage.Literals.ENUMERATION_LITERAL__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, SemanticmanagerPackage.Literals.ENUMERATION_LITERAL__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getEnumerationLiteralAccess().getValueEIntParserRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEnumerationLiteralAccess().getLiteralEStringParserRuleCall_3_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ResourceElement returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (name=EString (literals+=EnumerationLiteral literals+=EnumerationLiteral*)?)
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaData returns MetaData
	 *
	 * Constraint:
	 *     (key=EString value=EString)
	 */
	protected void sequence_MetaData(ISerializationContext context, MetaData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient((EObject) semanticObject, SemanticmanagerPackage.Literals.META_DATA__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, SemanticmanagerPackage.Literals.META_DATA__KEY));
			if (transientValues.isValueTransient((EObject) semanticObject, SemanticmanagerPackage.Literals.META_DATA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject) semanticObject, SemanticmanagerPackage.Literals.META_DATA__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, (EObject) semanticObject);
		feeder.accept(grammarAccess.getMetaDataAccess().getKeyEStringParserRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMetaDataAccess().getValueEStringParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns ObjectProperty
	 *     ObjectProperty returns ObjectProperty
	 *
	 * Constraint:
	 *     (name=EString range=[SemanticNode|EString] (lowerBound=EInt upperBound=EInt)? (metadata+=MetaData metadata+=MetaData*)?)
	 */
	protected void sequence_ObjectProperty(ISerializationContext context, ObjectProperty semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns PrimitiveTypeDataProperty
	 *     PrimitiveTypeDataProperty returns PrimitiveTypeDataProperty
	 *
	 * Constraint:
	 *     (name=EString type=Type (lowerBound=EInt upperBound=EInt)? (metadata+=MetaData metadata+=MetaData*)?)
	 */
	protected void sequence_PrimitiveTypeDataProperty(ISerializationContext context, PrimitiveTypeDataProperty semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RepositoryManager returns RepositoryManager
	 *
	 * Constraint:
	 *     (repositories+=Repository repositories+=Repository*)?
	 */
	protected void sequence_RepositoryManager(ISerializationContext context, RepositoryManager semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Repository returns Repository
	 *
	 * Constraint:
	 *     (name=EString resources+=Resource resources+=Resource*)
	 */
	protected void sequence_Repository(ISerializationContext context, Repository semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Resource returns Resource
	 *     ResourceElement returns Resource
	 *
	 * Constraint:
	 *     (
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         assistant=EString 
	 *         name=EString 
	 *         (resourceElements+=ResourceElement resourceElements+=ResourceElement*)? 
	 *         (metadata+=MetaData metadata+=MetaData*)?
	 *     )
	 */
	protected void sequence_Resource(ISerializationContext context, Resource semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResourceElement returns SemanticNode
	 *     SemanticNode returns SemanticNode
	 *
	 * Constraint:
	 *     (
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         abstract?='abstract'? 
	 *         name=EString 
	 *         (properties+=Property properties+=Property*)? 
	 *         (metadata+=MetaData metadata+=MetaData*)?
	 *     )
	 */
	protected void sequence_SemanticNode(ISerializationContext context, SemanticNode semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
}
