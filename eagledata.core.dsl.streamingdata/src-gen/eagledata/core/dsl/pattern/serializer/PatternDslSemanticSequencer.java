/*
 * generated by Xtext 2.9.2
 */
package eagledata.core.dsl.pattern.serializer;

import com.google.inject.Inject;
import eagledata.core.dsl.pattern.services.PatternDslGrammarAccess;
import eagledata.core.dsl.pattern.streamingDsl.BooleanOption;
import eagledata.core.dsl.pattern.streamingDsl.GeoOption;
import eagledata.core.dsl.pattern.streamingDsl.Import;
import eagledata.core.dsl.pattern.streamingDsl.IntOption;
import eagledata.core.dsl.pattern.streamingDsl.LanguageOption;
import eagledata.core.dsl.pattern.streamingDsl.LatitudeLongitude;
import eagledata.core.dsl.pattern.streamingDsl.Phrase;
import eagledata.core.dsl.pattern.streamingDsl.Place;
import eagledata.core.dsl.pattern.streamingDsl.Point;
import eagledata.core.dsl.pattern.streamingDsl.Region;
import eagledata.core.dsl.pattern.streamingDsl.SourceOption;
import eagledata.core.dsl.pattern.streamingDsl.StreamingDslPackage;
import eagledata.core.dsl.pattern.streamingDsl.StreamingModel;
import eagledata.core.dsl.pattern.streamingDsl.TermKey;
import eagledata.core.dsl.pattern.streamingDsl.TermList;
import eagledata.core.dsl.pattern.streamingDsl.UTM;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class PatternDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PatternDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == StreamingDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StreamingDslPackage.BOOLEAN_OPTION:
				sequence_BooleanOption(context, (BooleanOption) semanticObject); 
				return; 
			case StreamingDslPackage.GEO_OPTION:
				sequence_GeoOption(context, (GeoOption) semanticObject); 
				return; 
			case StreamingDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case StreamingDslPackage.INT_OPTION:
				sequence_IntOption(context, (IntOption) semanticObject); 
				return; 
			case StreamingDslPackage.LANGUAGE_OPTION:
				sequence_LanguageOption(context, (LanguageOption) semanticObject); 
				return; 
			case StreamingDslPackage.LATITUDE_LONGITUDE:
				sequence_LatLong(context, (LatitudeLongitude) semanticObject); 
				return; 
			case StreamingDslPackage.PHRASE:
				sequence_Phrase(context, (Phrase) semanticObject); 
				return; 
			case StreamingDslPackage.PLACE:
				sequence_Place(context, (Place) semanticObject); 
				return; 
			case StreamingDslPackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			case StreamingDslPackage.REGION:
				sequence_Region(context, (Region) semanticObject); 
				return; 
			case StreamingDslPackage.SOURCE_OPTION:
				sequence_SourceOption(context, (SourceOption) semanticObject); 
				return; 
			case StreamingDslPackage.STREAMING_MODEL:
				sequence_StreamingModel(context, (StreamingModel) semanticObject); 
				return; 
			case StreamingDslPackage.TERM_KEY:
				sequence_TermKey(context, (TermKey) semanticObject); 
				return; 
			case StreamingDslPackage.TERM_LIST:
				sequence_TermList(context, (TermList) semanticObject); 
				return; 
			case StreamingDslPackage.UTM:
				sequence_UTM(context, (UTM) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Option returns BooleanOption
	 *     BooleanOption returns BooleanOption
	 *
	 * Constraint:
	 *     (key=BooleanOptionKey value=BOOLEAN)
	 */
	protected void sequence_BooleanOption(ISerializationContext context, BooleanOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.BOOLEAN_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.BOOLEAN_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.BOOLEAN_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.BOOLEAN_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanOptionAccess().getKeyBooleanOptionKeyEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getBooleanOptionAccess().getValueBOOLEANTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns GeoOption
	 *     GeoOption returns GeoOption
	 *
	 * Constraint:
	 *     (key=GeoOptionKey value=[GeographicalElement|QualifiedName])
	 */
	protected void sequence_GeoOption(ISerializationContext context, GeoOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.GEO_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.GEO_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.GEO_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.GEO_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeoOptionAccess().getKeyGeoOptionKeyEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getGeoOptionAccess().getValueGeographicalElementQualifiedNameParserRuleCall_2_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StreamingDescription returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns IntOption
	 *     IntOption returns IntOption
	 *
	 * Constraint:
	 *     (key=IntOptionKey value=INT)
	 */
	protected void sequence_IntOption(ISerializationContext context, IntOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.INT_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.INT_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.INT_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.INT_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntOptionAccess().getKeyIntOptionKeyEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getIntOptionAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns LanguageOption
	 *     LanguageOption returns LanguageOption
	 *
	 * Constraint:
	 *     (key=LanguageOptionKey value=Language)
	 */
	protected void sequence_LanguageOption(ISerializationContext context, LanguageOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.LANGUAGE_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.LANGUAGE_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.LANGUAGE_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.LANGUAGE_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageOptionAccess().getKeyLanguageOptionKeyEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getLanguageOptionAccess().getValueLanguageEnumRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Coordinate returns LatitudeLongitude
	 *     LatLong returns LatitudeLongitude
	 *
	 * Constraint:
	 *     (lat=DOUBLE long=DOUBLE)
	 */
	protected void sequence_LatLong(ISerializationContext context, LatitudeLongitude semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.LATITUDE_LONGITUDE__LAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.LATITUDE_LONGITUDE__LAT));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.LATITUDE_LONGITUDE__LONG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.LATITUDE_LONGITUDE__LONG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLatLongAccess().getLatDOUBLETerminalRuleCall_0_0(), semanticObject.getLat());
		feeder.accept(grammarAccess.getLatLongAccess().getLongDOUBLETerminalRuleCall_2_0(), semanticObject.getLong());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StreamingDescription returns Phrase
	 *     PatternMatcherElement returns Phrase
	 *     Phrase returns Phrase
	 *
	 * Constraint:
	 *     (name=ID ordered?='ordered'? concepts+=Concept concepts+=Concept* (options+=Option options+=Option*)?)
	 */
	protected void sequence_Phrase(ISerializationContext context, Phrase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StreamingDescription returns Place
	 *     GeographicalElement returns Place
	 *     Place returns Place
	 *
	 * Constraint:
	 *     (name=ID point=Point)
	 */
	protected void sequence_Place(ISerializationContext context, Place semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.GEOGRAPHICAL_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.GEOGRAPHICAL_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.PLACE__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.PLACE__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlaceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPlaceAccess().getPointPointParserRuleCall_3_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Point
	 *
	 * Constraint:
	 *     ((radius=DOUBLE mesurement=DistanceMesurement)? coordinates=Coordinate)
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StreamingDescription returns Region
	 *     GeographicalElement returns Region
	 *     Region returns Region
	 *
	 * Constraint:
	 *     (name=ID southWestBoundary=Point northEastBoundary=Point)
	 */
	protected void sequence_Region(ISerializationContext context, Region semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.GEOGRAPHICAL_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.GEOGRAPHICAL_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.REGION__SOUTH_WEST_BOUNDARY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.REGION__SOUTH_WEST_BOUNDARY));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.REGION__NORTH_EAST_BOUNDARY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.REGION__NORTH_EAST_BOUNDARY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRegionAccess().getSouthWestBoundaryPointParserRuleCall_4_0(), semanticObject.getSouthWestBoundary());
		feeder.accept(grammarAccess.getRegionAccess().getNorthEastBoundaryPointParserRuleCall_6_0(), semanticObject.getNorthEastBoundary());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns SourceOption
	 *     SourceOption returns SourceOption
	 *
	 * Constraint:
	 *     (key=SourceOptionKey value=Source)
	 */
	protected void sequence_SourceOption(ISerializationContext context, SourceOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.SOURCE_OPTION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.SOURCE_OPTION__KEY));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.SOURCE_OPTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.SOURCE_OPTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceOptionAccess().getKeySourceOptionKeyEnumRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getSourceOptionAccess().getValueSourceEnumRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StreamingModel returns StreamingModel
	 *
	 * Constraint:
	 *     (descriptions+=StreamingDescription descriptions+=StreamingDescription*)
	 */
	protected void sequence_StreamingModel(ISerializationContext context, StreamingModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StreamingDescription returns TermKey
	 *     PatternMatcherElement returns TermKey
	 *     Concept returns TermKey
	 *     TermKey returns TermKey
	 *
	 * Constraint:
	 *     (type=BasicType name=ID)
	 */
	protected void sequence_TermKey(ISerializationContext context, TermKey semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.TERM_KEY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.TERM_KEY__TYPE));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.PATTERN_MATCHER_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.PATTERN_MATCHER_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermKeyAccess().getTypeBasicTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getTermKeyAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StreamingDescription returns TermList
	 *     PatternMatcherElement returns TermList
	 *     Concept returns TermList
	 *     TermList returns TermList
	 *
	 * Constraint:
	 *     (property=WordListProperty? name=ID (terms+=STRING terms+=STRING*)?)
	 */
	protected void sequence_TermList(ISerializationContext context, TermList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Coordinate returns UTM
	 *     UTM returns UTM
	 *
	 * Constraint:
	 *     (e=DOUBLE n=DOUBLE z=DOUBLE Hemi=DOUBLE)
	 */
	protected void sequence_UTM(ISerializationContext context, UTM semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.UTM__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.UTM__E));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.UTM__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.UTM__N));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.UTM__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.UTM__Z));
			if (transientValues.isValueTransient(semanticObject, StreamingDslPackage.Literals.UTM__HEMI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StreamingDslPackage.Literals.UTM__HEMI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUTMAccess().getEDOUBLETerminalRuleCall_2_0(), semanticObject.getE());
		feeder.accept(grammarAccess.getUTMAccess().getNDOUBLETerminalRuleCall_4_0(), semanticObject.getN());
		feeder.accept(grammarAccess.getUTMAccess().getZDOUBLETerminalRuleCall_6_0(), semanticObject.getZ());
		feeder.accept(grammarAccess.getUTMAccess().getHemiDOUBLETerminalRuleCall_8_0(), semanticObject.getHemi());
		feeder.finish();
	}
	
	
}
