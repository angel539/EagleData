/*
 * generated by Xtext 2.9.1
 */
package eagledata.core.dsl.datadesc.validation

import org.eclipse.xtext.validation.Check
import eagledata.core.dsl.datadesc.dataDsl.DataType
import eagledata.core.dsl.datadesc.dataDsl.DataDslPackage
import java.util.regex.Pattern
import java.util.regex.PatternSyntaxException

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DataDslValidator extends AbstractDataDslValidator {
	//public static val INVALID_NAME = 'invalidName'
	public static val DATATYPE_OPTION_NAME = 'invalidOption'
	
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					DataDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
/*
 * @Check
	def checkDataTypeOptions(LeafNode leafNode) {
		if(leafNode.type instanceof DataType){
			val DataType datatype = leafNode.type as DataType
			
			switch datatype.type{
				case "INTEGER":
					leafNode.options.forEach[
				 	option | if(!option.key.equals("NULL") && !option.key.equals("SEPARATOR") && !option.key.equals("DEFAULT"))
									error('Options are not valid for an INTEGER', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME) 
					]
				case "FLOATSTRING":{
					leafNode.options.forEach[
				 	option | if(!option.key.equals("NULL") && !option.key.equals("SEPARATOR") && !option.key.equals("DEFAULT") && !option.key.equals("DECIMALCHAR") && !option.key.equals("GROUPCHAR") && !option.key.equals("PATTERN"))
									error('Options are not valid for a FLOAT', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
							else{
								if(option.key.equals("DECIMALCHAR")){
									if(!option.value.equals(".") && !option.value.equals(",") && !option.value.equals("'"))
										error('DECIMALCHAR. Option must be a ".", ",", "\'"', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
								} 
							}	 
					]
					
					if(leafNode.options.filter(option | option.key.equals("DECIMALCHAR")).size < 1)
							warning('DECIMALCHAR. You should consider to specify a character for the decimal separator. "." will be consider by default', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
				}
				case "BOOLEAN":
				 	leafNode.options.forEach[
				 	option | if(!option.key.equals("NULL") && !option.key.equals("FORMAT"))
									error('Options are not valid for a BOOLEAN', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
								else
									if(!option.value.contains("|"))
										warning('BOOLEAN. Implementation does not contain value for FALSE representation (must use | separator): TRUE | FALSE', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
					]
				case "DATE":{
					 	leafNode.options.forEach[
					 	option | if(!option.key.equals("NULL") && !option.key.equals("FORMAT") && !option.key.equals("SEPARATOR"))
										error('Options are not valid for a DATE', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
									else{
										if(option.key.equals("FORMAT")){
											//val String option_value = option.value
											option.value.toCharArray.forEach[
												c | if(!(Character.compare(c, 'M')==0) && !(Character.compare(c, 'm')==0)
													&& !(Character.compare(c, 'D')==0) && !(Character.compare(c, 'd')==0)
													&& !(Character.compare(c, 'Y')==0) && !(Character.compare(c, 'y')==0))
														error('FORMAT not correctly spell. MUST USE M/m for MONTHS, D/d for DAYS, Y/y for YEARS', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
											]
											
											var Integer mChar = option.value.toCharArray.filter(c | Character.compare(c, 'M')==0 || Character.compare(c, 'm')==0).size
											if(mChar > 2)
												 error('FORMAT not correctly spell. MONTHS must have less than 2 CHARS. 100th month does not exist (maybe in Pluto)', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
											var Integer dChar = option.value.toCharArray.filter(c | Character.compare(c, 'D')==0 || Character.compare(c, 'd')==0).size
											if(dChar > 2)
												 error('FORMAT not correctly spell. DAYS must have less than 2 CHARS. 100th day does not exist (maybe in Pluto)', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
											var Integer yChar = option.value.toCharArray.filter(c | Character.compare(c, 'Y')==0 || Character.compare(c, 'y')==0).size
											if(yChar > 4)
												 error('FORMAT not correctly spell. YEARS must have less than 4 CHARS. WHOW, you get to the 10000th year! How it is? Cars can fly?', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
										}
									}
						]
						if(leafNode.options.filter(option | option.key.equals("SEPARATOR")).size < 1)
							warning('SEPARATOR not DEFINED. You should consider to specify a separator character', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
						if(leafNode.options.filter(option | option.key.equals("FORMAT")).size < 1)
							warning('FORMAT not DEFINED. You should consider to specify a format string. MMddYYYY could be one', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
					}
				case "TIME":
				 	{
					 	leafNode.options.forEach[
					 	option | if(!option.key.equals("NULL") && !option.key.equals("FORMAT") && !option.key.equals("SEPARATOR"))
										error('Options are not valid for a TIME', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
									else{
										if(option.key.equals("FORMAT")){
											//val String option_value = option.value
											option.value.toCharArray.forEach[
												c | if(!(Character.compare(c, 'H')==0) && !(Character.compare(c, 'h')==0)
													&& !(Character.compare(c, 'M')==0) && !(Character.compare(c, 'm')==0)
													&& !(Character.compare(c, 'S')==0) && !(Character.compare(c, 's')==0))
														error('FORMAT not correctly spell. MUST USE H/h for HOURS, M/m for MINUTES, S/s for SECONDS', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
											]
											
											var Integer hChar = option.value.toCharArray.filter(c | Character.compare(c, 'H')==0 || Character.compare(c, 'h')==0).size
											if(hChar > 2)
												 error('FORMAT not correctly spell. HOURS must have less than 2 CHARS. See you at fifteen to 125, buddy', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
											var Integer mChar = option.value.toCharArray.filter(c | Character.compare(c, 'M')==0 || Character.compare(c, 'm')==0).size
											if(mChar > 2)
												 error('FORMAT not correctly spell. MINUTES must have less than 2 CHARS. 100 minutes is 1 hour and 40 minutes HMM', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
											var Integer sChar = option.value.toCharArray.filter(c | Character.compare(c, 'S')==0 || Character.compare(c, 's')==0).size
											if(sChar > 4)
												 error('FORMAT not correctly spell. SECONDS must have less than 2 CHARS. 100 seconds is 1 minute and 40 seconds Mss', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
										}
									}
						]
						if(leafNode.options.filter(option | option.key.equals("SEPARATOR")).size < 1)
							warning('SEPARATOR not DEFINED. You should consider to specify a separator character', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
						if(leafNode.options.filter(option | option.key.equals("FORMAT")).size < 1)
							warning('FORMAT not DEFINED. You should consider to specify a format string. HHmmSS could be one', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
					}
				case "YEAR":
				 	leafNode.options.forEach[
				 	option | if(!option.key.equals("NULL") && !option.key.equals("FORMAT"))
									error('Options are not valid for a YEAR', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
							else{
								if(option.key.equals("FORMAT")){
									//val String option_value = option.value
									option.value.toCharArray.forEach[
										c | !(Character.compare(c, 'Y')==0) && !(Character.compare(c, 'y')==0)
										error('FORMAT not correctly spell. MUST USE Y/y for YEARS', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
									]
											
									var Integer yChar = option.value.toCharArray.filter(c | Character.compare(c, 'Y')==0 || Character.compare(c, 'y')==0).size
									if(yChar > 4)
										error('FORMAT not correctly spell. YEARS must have less than 4 CHARS. WHOW, you get to the 10000th year! How it is? Cars can fly?', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
								}
							}
					]
				case "MONTH":
				 	leafNode.options.forEach[
				 	option | if(!option.key.equals("NULL") && !option.key.equals("FORMAT"))
									error('Options are not valid for a MONTH', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
							else{
								if(option.key.equals("FORMAT")){
									//val String option_value = option.value
									option.value.toCharArray.forEach[
										c | !(Character.compare(c, 'M')==0) && !(Character.compare(c, 'm')==0)
										error('FORMAT not correctly spell. MUST USE M/m for MONTHS', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
									]
									
									var Integer mChar = option.value.toCharArray.filter(c | Character.compare(c, 'M')==0 || Character.compare(c, 'm')==0).size	
									if(mChar > 2)
										error('FORMAT not correctly spell. MONTHS must have less than 2 CHARS. 100th month does not exist (maybe in Pluto)', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
								}
							}
					]
				case "DAY":
				 	leafNode.options.forEach[
				 	option | if(!option.key.equals("NULL") && !option.key.equals("FORMAT"))
									error('Options are not valid for a DAY', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
							else{
								if(option.key.equals("FORMAT")){
									//val String option_value = option.value
									option.value.toCharArray.forEach[
										c | !(Character.compare(c, 'D')==0) && !(Character.compare(c, 'd')==0)
										error('FORMAT not correctly spell. MUST USE D/d for DAYS', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
									]
									var Integer dChar = option.value.toCharArray.filter(c | Character.compare(c, 'D')==0 || Character.compare(c, 'd')==0).size
									if(dChar > 2)
										error('FORMAT not correctly spell. DAYS must have less than 2 CHARS. 100th day does not exist (maybe in Pluto)', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)	
								}
							}
					]
				case "STRING":
				 	leafNode.options.forEach[
				 	option | if(!option.key.equals("NULL") && !option.key.equals("REGEX") && !option.key.equals("REGEX_FLAGS"))
									error('Options are not valid for an STRING', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
							else{
								if(option.key.equals("REGEX")){
									try{
										Pattern.compile(option.value);
									}catch(PatternSyntaxException exception){
										error('STRING. REGEX is not valid. See (https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html) for valid pattern', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
									}
								}
								
								if(option.key.equals("REGEX_FLAGS")){
									var Integer dChar = leafNode.options.filter(o | o.key.equals("REGEX")==0).size
									if(dChar < 1)
										error('REGEX_FLAGS can not be called without REGEX option', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
									
									if(!option.value.equals("CASE_INSENSITIVE") && !option.value.equals("MULTILINE")
											&& !option.value.equals("DOTALL") && !option.value.equals("UNICODE_CASE")
											&& !option.value.equals("CANON_EQ") && !option.value.equals("UNIX_LINES")
											&& !option.value.equals("LITERAL") && !option.value.equals("UNICODE_CHARACTERE_CLASS")
											&& !option.value.equals("COMMENTS")){
										error('STRING. REGEX_FLAGS is not valid. See (https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#compile(java.lang.String)) for help. It is hard but if Leo could win the Oscar you can do this.', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
									}
									// CASE_INSENSITIVE, MULTILINE, DOTALL, UNICODE_CASE, CANON_EQ, UNIX_LINES, LITERAL, UNICODE_CHARACTER_CLASS, COMMENTS
								}
							}
					]
				case "LAT":
				 	leafNode.options.forEach[
				 	option | if(!option.key.equals("NULL"))
									error('Options are not valid for an LAT', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
					]
				case "LONG":
				 	leafNode.options.forEach[
				 	option | if(!option.key.equals("NULL"))
									error('Options are not valid for an LONG', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
					]	 
				default : 
					error('Options are not valid for node. Type not correct', DataDslPackage.Literals.NODE__NAME, DATATYPE_OPTION_NAME)
			}
		}
	}
 */
	
}
