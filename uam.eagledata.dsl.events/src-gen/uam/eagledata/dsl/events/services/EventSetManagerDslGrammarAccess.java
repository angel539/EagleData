/*
 * generated by Xtext 2.9.2
 */
package uam.eagledata.dsl.events.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class EventSetManagerDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class EventSetManagerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.EventSetManager");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEventsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cEventsEventParserRuleCall_0_0 = (RuleCall)cEventsAssignment_0.eContents().get(0);
		private final Assignment cEventsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEventsEventParserRuleCall_1_0 = (RuleCall)cEventsAssignment_1.eContents().get(0);
		
		//EventSetManager events::EventSetManager:
		//	events+=Event events+=Event*
		@Override public ParserRule getRule() { return rule; }
		
		//events+=Event events+=Event*
		public Group getGroup() { return cGroup; }
		
		//events+=Event
		public Assignment getEventsAssignment_0() { return cEventsAssignment_0; }
		
		//Event
		public RuleCall getEventsEventParserRuleCall_0_0() { return cEventsEventParserRuleCall_0_0; }
		
		//events+=Event*
		public Assignment getEventsAssignment_1() { return cEventsAssignment_1; }
		
		//Event
		public RuleCall getEventsEventParserRuleCall_1_0() { return cEventsEventParserRuleCall_1_0; }
	}
	public class EventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.Event");
		private final RuleCall cPatternEventParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Event events::Event:
		//	PatternEvent
		@Override public ParserRule getRule() { return rule; }
		
		//PatternEvent
		public RuleCall getPatternEventParserRuleCall() { return cPatternEventParserRuleCall; }
	}
	public class PatternEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.PatternEvent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPatternEventAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPatternKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameEStringParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConceptsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConceptsConceptParserRuleCall_4_0 = (RuleCall)cConceptsAssignment_4.eContents().get(0);
		private final Assignment cConceptsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cConceptsConceptParserRuleCall_5_0 = (RuleCall)cConceptsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cIfKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cWhenAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cWhenConditionParserRuleCall_7_1_0 = (RuleCall)cWhenAssignment_7_1.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cThenKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cTriggersAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cTriggersEStringParserRuleCall_8_1_0 = (RuleCall)cTriggersAssignment_8_1.eContents().get(0);
		private final Assignment cTriggersAssignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cTriggersEStringParserRuleCall_8_2_0 = (RuleCall)cTriggersAssignment_8_2.eContents().get(0);
		
		//PatternEvent events::PatternEvent:
		//	{events::PatternEvent}
		//	'pattern' name=EString '{'
		//	concepts+=Concept concepts+=Concept*
		//	'}' ('if' when=Condition)? ('then' triggers+=EString triggers+=EString*)
		@Override public ParserRule getRule() { return rule; }
		
		//{events::PatternEvent} 'pattern' name=EString '{' concepts+=Concept concepts+=Concept* '}' ('if' when=Condition)?
		//('then' triggers+=EString triggers+=EString*)
		public Group getGroup() { return cGroup; }
		
		//{events::PatternEvent}
		public Action getPatternEventAction_0() { return cPatternEventAction_0; }
		
		//'pattern'
		public Keyword getPatternKeyword_1() { return cPatternKeyword_1; }
		
		//name=EString
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_2_0() { return cNameEStringParserRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//concepts+=Concept
		public Assignment getConceptsAssignment_4() { return cConceptsAssignment_4; }
		
		//Concept
		public RuleCall getConceptsConceptParserRuleCall_4_0() { return cConceptsConceptParserRuleCall_4_0; }
		
		//concepts+=Concept*
		public Assignment getConceptsAssignment_5() { return cConceptsAssignment_5; }
		
		//Concept
		public RuleCall getConceptsConceptParserRuleCall_5_0() { return cConceptsConceptParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
		
		//('if' when=Condition)?
		public Group getGroup_7() { return cGroup_7; }
		
		//'if'
		public Keyword getIfKeyword_7_0() { return cIfKeyword_7_0; }
		
		//when=Condition
		public Assignment getWhenAssignment_7_1() { return cWhenAssignment_7_1; }
		
		//Condition
		public RuleCall getWhenConditionParserRuleCall_7_1_0() { return cWhenConditionParserRuleCall_7_1_0; }
		
		//('then' triggers+=EString triggers+=EString*)
		public Group getGroup_8() { return cGroup_8; }
		
		//'then'
		public Keyword getThenKeyword_8_0() { return cThenKeyword_8_0; }
		
		//triggers+=EString
		public Assignment getTriggersAssignment_8_1() { return cTriggersAssignment_8_1; }
		
		//EString
		public RuleCall getTriggersEStringParserRuleCall_8_1_0() { return cTriggersEStringParserRuleCall_8_1_0; }
		
		//triggers+=EString*
		public Assignment getTriggersAssignment_8_2() { return cTriggersAssignment_8_2; }
		
		//EString
		public RuleCall getTriggersEStringParserRuleCall_8_2_0() { return cTriggersEStringParserRuleCall_8_2_0; }
	}
	public class ConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.Condition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBinaryExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Condition events::Condition:
		//	BinaryExpression | BooleanExpression
		@Override public ParserRule getRule() { return rule; }
		
		//BinaryExpression | BooleanExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BinaryExpression
		public RuleCall getBinaryExpressionParserRuleCall_0() { return cBinaryExpressionParserRuleCall_0; }
		
		//BooleanExpression
		public RuleCall getBooleanExpressionParserRuleCall_1() { return cBooleanExpressionParserRuleCall_1; }
	}
	public class BinaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.BinaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cLeftConceptCrossReference_0_0 = (CrossReference)cLeftAssignment_0.eContents().get(0);
		private final RuleCall cLeftConceptEStringParserRuleCall_0_0_1 = (RuleCall)cLeftConceptCrossReference_0_0.eContents().get(1);
		private final Keyword cSpaceEqualsSignSpaceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightLiteralParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//BinaryExpression events::BinaryExpression:
		//	left=[events::Concept|EString] ' = ' right=Literal
		@Override public ParserRule getRule() { return rule; }
		
		//left=[events::Concept|EString] ' = ' right=Literal
		public Group getGroup() { return cGroup; }
		
		//left=[events::Concept|EString]
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//[events::Concept|EString]
		public CrossReference getLeftConceptCrossReference_0_0() { return cLeftConceptCrossReference_0_0; }
		
		//EString
		public RuleCall getLeftConceptEStringParserRuleCall_0_0_1() { return cLeftConceptEStringParserRuleCall_0_0_1; }
		
		//' = '
		public Keyword getSpaceEqualsSignSpaceKeyword_1() { return cSpaceEqualsSignSpaceKeyword_1; }
		
		//right=Literal
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Literal
		public RuleCall getRightLiteralParserRuleCall_2_0() { return cRightLiteralParserRuleCall_2_0; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.Literal");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueEStringParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Literal events::Literal:
		//	value=EString
		@Override public ParserRule getRule() { return rule; }
		
		//value=EString
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//EString
		public RuleCall getValueEStringParserRuleCall_0() { return cValueEStringParserRuleCall_0; }
	}
	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.BooleanExpression");
		private final Assignment cExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpressionBOOLEANTerminalRuleCall_0 = (RuleCall)cExpressionAssignment.eContents().get(0);
		
		//BooleanExpression events::BooleanExpression:
		//	expression=BOOLEAN
		@Override public ParserRule getRule() { return rule; }
		
		//expression=BOOLEAN
		public Assignment getExpressionAssignment() { return cExpressionAssignment; }
		
		//BOOLEAN
		public RuleCall getExpressionBOOLEANTerminalRuleCall_0() { return cExpressionBOOLEANTerminalRuleCall_0; }
	}
	public class ConceptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.Concept");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKeyConceptParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRegexConceptParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Concept events::Concept:
		//	KeyConcept | RegexConcept
		@Override public ParserRule getRule() { return rule; }
		
		//KeyConcept | RegexConcept
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//KeyConcept
		public RuleCall getKeyConceptParserRuleCall_0() { return cKeyConceptParserRuleCall_0; }
		
		//RegexConcept
		public RuleCall getRegexConceptParserRuleCall_1() { return cRegexConceptParserRuleCall_1; }
	}
	public class KeyConceptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.KeyConcept");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cKeyConceptAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeEnumRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameEStringParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//KeyConcept events::KeyConcept:
		//	{events::KeyConcept} type=Type name=EString
		@Override public ParserRule getRule() { return rule; }
		
		//{events::KeyConcept} type=Type name=EString
		public Group getGroup() { return cGroup; }
		
		//{events::KeyConcept}
		public Action getKeyConceptAction_0() { return cKeyConceptAction_0; }
		
		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//Type
		public RuleCall getTypeTypeEnumRuleCall_1_0() { return cTypeTypeEnumRuleCall_1_0; }
		
		//name=EString
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_2_0() { return cNameEStringParserRuleCall_2_0; }
	}
	public class RegexConceptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.RegexConcept");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRegexConceptAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeEnumRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameEStringParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRegexAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRegexEStringParserRuleCall_4_0 = (RuleCall)cRegexAssignment_4.eContents().get(0);
		
		//RegexConcept events::RegexConcept:
		//	{events::RegexConcept} type=Type name=EString '=' regex=EString
		@Override public ParserRule getRule() { return rule; }
		
		//{events::RegexConcept} type=Type name=EString '=' regex=EString
		public Group getGroup() { return cGroup; }
		
		//{events::RegexConcept}
		public Action getRegexConceptAction_0() { return cRegexConceptAction_0; }
		
		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//Type
		public RuleCall getTypeTypeEnumRuleCall_1_0() { return cTypeTypeEnumRuleCall_1_0; }
		
		//name=EString
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_2_0() { return cNameEStringParserRuleCall_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }
		
		//regex=EString
		public Assignment getRegexAssignment_4() { return cRegexAssignment_4; }
		
		//EString
		public RuleCall getRegexEStringParserRuleCall_4_0() { return cRegexEStringParserRuleCall_4_0; }
	}
	public class ActionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.Action");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cActionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameEStringParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Action events::Action:
		//	{events::Action} name=EString
		@Override public ParserRule getRule() { return rule; }
		
		//{events::Action} name=EString
		public Group getGroup() { return cGroup; }
		
		//{events::Action}
		public Action getActionAction_0() { return cActionAction_0; }
		
		//name=EString
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//EString
		public RuleCall getNameEStringParserRuleCall_1_0() { return cNameEStringParserRuleCall_1_0; }
	}
	public class EStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.EString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EString:
		//	STRING | ID;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING | ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
	}
	
	public class TypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cStringEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cStringStringKeyword_0_0 = (Keyword)cStringEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIntEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIntIntKeyword_1_0 = (Keyword)cIntEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cBooleanEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cBooleanBooleanKeyword_2_0 = (Keyword)cBooleanEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cFloatEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cFloatFloatKeyword_3_0 = (Keyword)cFloatEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cDoubleEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cDoubleDoubleKeyword_4_0 = (Keyword)cDoubleEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum Type returns events::Type:
		//	String | Int | Boolean | Float | Double;
		public EnumRule getRule() { return rule; }
		
		//String | Int | Boolean | Float | Double
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//String
		public EnumLiteralDeclaration getStringEnumLiteralDeclaration_0() { return cStringEnumLiteralDeclaration_0; }
		
		//'String'
		public Keyword getStringStringKeyword_0_0() { return cStringStringKeyword_0_0; }
		
		//Int
		public EnumLiteralDeclaration getIntEnumLiteralDeclaration_1() { return cIntEnumLiteralDeclaration_1; }
		
		//'Int'
		public Keyword getIntIntKeyword_1_0() { return cIntIntKeyword_1_0; }
		
		//Boolean
		public EnumLiteralDeclaration getBooleanEnumLiteralDeclaration_2() { return cBooleanEnumLiteralDeclaration_2; }
		
		//'Boolean'
		public Keyword getBooleanBooleanKeyword_2_0() { return cBooleanBooleanKeyword_2_0; }
		
		//Float
		public EnumLiteralDeclaration getFloatEnumLiteralDeclaration_3() { return cFloatEnumLiteralDeclaration_3; }
		
		//'Float'
		public Keyword getFloatFloatKeyword_3_0() { return cFloatFloatKeyword_3_0; }
		
		//Double
		public EnumLiteralDeclaration getDoubleEnumLiteralDeclaration_4() { return cDoubleEnumLiteralDeclaration_4; }
		
		//'Double'
		public Keyword getDoubleDoubleKeyword_4_0() { return cDoubleDoubleKeyword_4_0; }
	}
	
	private final EventSetManagerElements pEventSetManager;
	private final EventElements pEvent;
	private final PatternEventElements pPatternEvent;
	private final ConditionElements pCondition;
	private final BinaryExpressionElements pBinaryExpression;
	private final LiteralElements pLiteral;
	private final BooleanExpressionElements pBooleanExpression;
	private final TerminalRule tBOOLEAN;
	private final ConceptElements pConcept;
	private final KeyConceptElements pKeyConcept;
	private final RegexConceptElements pRegexConcept;
	private final ActionElements pAction;
	private final EStringElements pEString;
	private final TypeElements eType;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public EventSetManagerDslGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pEventSetManager = new EventSetManagerElements();
		this.pEvent = new EventElements();
		this.pPatternEvent = new PatternEventElements();
		this.pCondition = new ConditionElements();
		this.pBinaryExpression = new BinaryExpressionElements();
		this.pLiteral = new LiteralElements();
		this.pBooleanExpression = new BooleanExpressionElements();
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "uam.eagledata.dsl.events.EventSetManagerDsl.BOOLEAN");
		this.pConcept = new ConceptElements();
		this.pKeyConcept = new KeyConceptElements();
		this.pRegexConcept = new RegexConceptElements();
		this.pAction = new ActionElements();
		this.pEString = new EStringElements();
		this.eType = new TypeElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("uam.eagledata.dsl.events.EventSetManagerDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//EventSetManager events::EventSetManager:
	//	events+=Event events+=Event*
	public EventSetManagerElements getEventSetManagerAccess() {
		return pEventSetManager;
	}
	
	public ParserRule getEventSetManagerRule() {
		return getEventSetManagerAccess().getRule();
	}
	
	//Event events::Event:
	//	PatternEvent
	public EventElements getEventAccess() {
		return pEvent;
	}
	
	public ParserRule getEventRule() {
		return getEventAccess().getRule();
	}
	
	//PatternEvent events::PatternEvent:
	//	{events::PatternEvent}
	//	'pattern' name=EString '{'
	//	concepts+=Concept concepts+=Concept*
	//	'}' ('if' when=Condition)? ('then' triggers+=EString triggers+=EString*)
	public PatternEventElements getPatternEventAccess() {
		return pPatternEvent;
	}
	
	public ParserRule getPatternEventRule() {
		return getPatternEventAccess().getRule();
	}
	
	//Condition events::Condition:
	//	BinaryExpression | BooleanExpression
	public ConditionElements getConditionAccess() {
		return pCondition;
	}
	
	public ParserRule getConditionRule() {
		return getConditionAccess().getRule();
	}
	
	//BinaryExpression events::BinaryExpression:
	//	left=[events::Concept|EString] ' = ' right=Literal
	public BinaryExpressionElements getBinaryExpressionAccess() {
		return pBinaryExpression;
	}
	
	public ParserRule getBinaryExpressionRule() {
		return getBinaryExpressionAccess().getRule();
	}
	
	//Literal events::Literal:
	//	value=EString
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//BooleanExpression events::BooleanExpression:
	//	expression=BOOLEAN
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return pBooleanExpression;
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}
	
	//terminal BOOLEAN:
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	}
	
	//Concept events::Concept:
	//	KeyConcept | RegexConcept
	public ConceptElements getConceptAccess() {
		return pConcept;
	}
	
	public ParserRule getConceptRule() {
		return getConceptAccess().getRule();
	}
	
	//KeyConcept events::KeyConcept:
	//	{events::KeyConcept} type=Type name=EString
	public KeyConceptElements getKeyConceptAccess() {
		return pKeyConcept;
	}
	
	public ParserRule getKeyConceptRule() {
		return getKeyConceptAccess().getRule();
	}
	
	//RegexConcept events::RegexConcept:
	//	{events::RegexConcept} type=Type name=EString '=' regex=EString
	public RegexConceptElements getRegexConceptAccess() {
		return pRegexConcept;
	}
	
	public ParserRule getRegexConceptRule() {
		return getRegexConceptAccess().getRule();
	}
	
	//Action events::Action:
	//	{events::Action} name=EString
	public ActionElements getActionAccess() {
		return pAction;
	}
	
	public ParserRule getActionRule() {
		return getActionAccess().getRule();
	}
	
	//EString:
	//	STRING | ID;
	public EStringElements getEStringAccess() {
		return pEString;
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}
	
	//enum Type returns events::Type:
	//	String | Int | Boolean | Float | Double;
	public TypeElements getTypeAccess() {
		return eType;
	}
	
	public EnumRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
